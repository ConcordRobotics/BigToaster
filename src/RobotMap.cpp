// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
// Test comment
// Connor's test comment


// Data for Robot Drive system
SpeedController* RobotMap::driveMotorsFrontLeftSC = NULL;
SpeedController* RobotMap::driveMotorsFrontRightSC = NULL;
SpeedController* RobotMap::driveMotorsBackLeftSC = NULL;
SpeedController* RobotMap::driveMotorsBackRightSC = NULL;
Encoder* RobotMap::driveMotorsFrontLeftEncoder = NULL;
Encoder* RobotMap::driveMotorsFrontRightEncoder = NULL;
Encoder* RobotMap::driveMotorsBackLeftEncoder = NULL;
Encoder* RobotMap::driveMotorsBackRightEncoder = NULL;
PIController* RobotMap::driveMotorsFrontLeftController = NULL;
PIController* RobotMap::driveMotorsFrontRightController = NULL;
PIController* RobotMap::driveMotorsBackLeftController = NULL;
PIController* RobotMap::driveMotorsBackRightController = NULL;
PIController* RobotMap::driveMotorsGyroController = NULL;
SingleMotor* RobotMap::driveMotorsFrontLeftMotor = NULL;
SingleMotor* RobotMap::driveMotorsFrontRightMotor = NULL;
SingleMotor* RobotMap::driveMotorsBackLeftMotor = NULL;
SingleMotor* RobotMap::driveMotorsBackRightMotor = NULL;
BuiltInAccelerometer* RobotMap::driveMotorsAccelerometer = NULL;
Gyro* RobotMap::driveMotorsGyro1 = NULL;

// Data for lift system
SpeedController* RobotMap::liftSC = NULL;
Encoder* RobotMap::liftEncoder = NULL;


void RobotMap::init() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	LiveWindow* lw = LiveWindow::GetInstance();

	// Set Drive Motor Data
		//Speed Controllers
			driveMotorsFrontLeftSC = new Talon(1);
			driveMotorsFrontRightSC = new Talon(3);
			driveMotorsBackLeftSC = new Talon(2);
			driveMotorsBackRightSC = new Talon(0);

		// Add the gyro and accelerometer
			driveMotorsGyro1 = new Gyro(0);
			lw->AddSensor("Gyros", "Gyro", driveMotorsGyro1);
			driveMotorsGyro1->SetSensitivity(0.007);
			driveMotorsAccelerometer = new BuiltInAccelerometer();
			lw->AddSensor("Gyros", "Accelerometer", driveMotorsAccelerometer);

		// Add the Encoders.
			// ToDo: Set the distance per pulse, and also the direction.
			// Use # revolutions as the distance.
			float distPerPulse = 1.0/293.0;
			driveMotorsFrontLeftEncoder = new Encoder(6, 7, true, Encoder::k4X);
			driveMotorsFrontLeftEncoder->SetDistancePerPulse(distPerPulse/1.34);
			//
			driveMotorsFrontRightEncoder = new Encoder(2, 3, false, Encoder::k4X);
			driveMotorsFrontRightEncoder->SetDistancePerPulse(distPerPulse/1.028);
			//
			driveMotorsBackLeftEncoder = new Encoder(4, 5, true, Encoder::k4X);
			driveMotorsBackLeftEncoder->SetDistancePerPulse(distPerPulse/1.4379);
			//
			driveMotorsBackRightEncoder = new Encoder(0, 1, false, Encoder::k4X);
			driveMotorsBackRightEncoder->SetDistancePerPulse(distPerPulse/0.65);
		// Add the Controllers
			// Setup some parameters to be used by all controllers
			// ToDo: These need to be calibrated
			double pGain = 10.0;
			double iGain = 0.0;
            double maxOutput = 1.0; // deg/sec
            double timeFilter = 0.01;
            double maxEnc = 1.0;
            bool PIControlled = false;
			driveMotorsFrontLeftController = new PIController(pGain, iGain, timeFilter, maxOutput, 0.0);
			driveMotorsFrontRightController = new PIController(pGain, iGain, timeFilter, maxOutput, 0.0);
			driveMotorsBackLeftController = new PIController(pGain, iGain, timeFilter, maxOutput, 0.0);
			driveMotorsBackRightController = new PIController(pGain, iGain, timeFilter, maxOutput, 0.0);
			driveMotorsGyroController = new PIController(pGain, iGain, timeFilter, maxOutput, 0.0);
		// Add the Motors
			driveMotorsFrontLeftMotor = new SingleMotor(driveMotorsFrontLeftSC, driveMotorsFrontLeftController, driveMotorsFrontLeftEncoder);
			driveMotorsFrontLeftMotor->PIControlled = PIControlled;
			driveMotorsFrontLeftMotor->scReversed = true;
			driveMotorsFrontLeftMotor->maxEnc = maxEnc;
			//
			driveMotorsFrontRightMotor = new SingleMotor(driveMotorsFrontRightSC, driveMotorsFrontRightController, driveMotorsFrontRightEncoder);
			driveMotorsFrontRightMotor->PIControlled = PIControlled;
			driveMotorsFrontRightMotor->scReversed = false;
			driveMotorsFrontRightMotor->maxEnc = maxEnc;
			//
			driveMotorsBackLeftMotor = new SingleMotor(driveMotorsBackLeftSC, driveMotorsBackLeftController, driveMotorsBackLeftEncoder);
			driveMotorsBackLeftMotor->PIControlled = PIControlled;
			driveMotorsBackLeftMotor->scReversed = true;
			driveMotorsBackLeftMotor->maxEnc = maxEnc;
			//
			driveMotorsBackRightMotor = new SingleMotor(driveMotorsBackRightSC, driveMotorsBackRightController, driveMotorsBackRightEncoder);
			driveMotorsBackRightMotor->PIControlled = PIControlled;
			driveMotorsBackRightMotor->scReversed = true;
			driveMotorsBackRightMotor->maxEnc = maxEnc;

		// Set up Live Windows
			lw->AddActuator("DriveMotors", "FrontLeftSC", (Talon*) driveMotorsFrontLeftSC);
			lw->AddSensor("DriveMotors", "FrontLeftEncoder", driveMotorsFrontLeftEncoder);
			lw->AddActuator("DriveMotors", "FrontRightSC", (Talon*) driveMotorsFrontRightSC);
			lw->AddSensor("DriveMotors", "FrontRightEncoder", driveMotorsFrontRightEncoder);
			lw->AddActuator("DriveMotors", "BackLeftSC", (Talon*) driveMotorsBackLeftSC);
			lw->AddSensor("DriveMotors", "BackLeftEncoder", driveMotorsBackLeftEncoder);
			lw->AddActuator("DriveMotors", "BackRightSC", (Talon*) driveMotorsBackRightSC);
			lw->AddSensor("DriveMotors", "BackRightEncoder", driveMotorsBackRightEncoder);

	// Set Lift Data
		// Speed Controller
			liftSC = new Victor(4);
			lw->AddActuator("Lift", "LiftMotor", (Victor*) liftSC);
		// The Encoder
			// ToDo: Set the distance per pulse, and also the direction.
			liftEncoder = new Encoder(8, 9, false, Encoder::k4X);
			lw->AddSensor("Lift", "LiftEncoder", liftEncoder);
			// Use inches for lift encoder
			liftEncoder->SetDistancePerPulse(0.0348);

}
