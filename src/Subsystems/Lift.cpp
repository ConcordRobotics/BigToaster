// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Lift.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/RaiseLift.h"
#include "../Commands/LowerLift.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

DriveMotors::DriveMotors() : Subsystem("DriveMotors") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	frontLeftSC = RobotMap::lift;
	frontRightSC = RobotMap::driveMotorsFrontRightSC;
	backLeftSC = RobotMap::driveMotorsBackLeftSC;
	backRightSC = RobotMap::driveMotorsBackRightSC;
	robotDrive = RobotMap::driveMotorsRobotDrive;
	gyro1 = RobotMap::driveMotorsGyro1;
	quadratureEncoder1 = RobotMap::driveMotorsQuadratureEncoder1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	accelerometer = RobotMap::driveMotorsAccelerometer;
	headingPIDOutput = RobotMap::driveMotorsHeadingPIDOutput;
	headingPIDController = RobotMap::driveMotorsHeadingPIDController;
	gyro1->Reset();
    targetHeading = gyro1->GetAngle();
    lastHeading = targetHeading;
    turning = false;
}
    
void DriveMotors::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveInTelop());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveMotors::arcadeDrive(float dx, float dy, float dz) {
	float currentHeading = gyro1->GetAngle();
	float dh = currentHeading - lastHeading;
	if (turning){
		if (dz==0.0){
			// It was turning but now isn't.  Lock into this angle
			turning = false;
			targetHeading = gyro1->GetAngle();
		} // If dz != 0, use the dz as turn rate
	} else {
		 if (dz != 0){
			// It's wasn't turning but now is
			 turning = true;
		 }
	}
	// Use PID output if not turning
	if (!turning) {
        if (abs(currentHeading - targetHeading)>5) {
        	targetHeading = 0.95*targetHeading + 0.05*currentHeading;
        }

		dz = ( targetHeading- gyro1->GetAngle())/100.0;
		//dz = headingPIDOutput->PIDOutput;
	}

	RobotMap::driveMotorsRobotDrive->MecanumDrive_Cartesian(dx,dy,dz);
	Wait(0.005); // wait 5ms to avoid hogging CPU cycles
	lastHeading = currentHeading;
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

